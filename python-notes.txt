pydoc notes


capella-> pydoc readline

or write HTML output:
capella-> pydoc -w atexit
wrote atexit.html

or start a web server listening on a port:
pydoc -p 5001
then browse at
http://localhost:5001/

doctest notes

an interesting way to convert strings to python types:

s = "GOOG,100,623.45"
field_types = [str, int, float]
fields = [ty(val) for ty, val in zip(field_types, s.split(','))]
fields
['GOOG', 100, 623.45]

python does support decimal arithmetic via the decimal module.

the sum(seq, initial) operator takes an initial value.
the type of the initial value usually determines the type of the result.
type conversion is apparently not done between the values to be summed:

>>> pprint(l)
[Decimal('24.5'), 25.5]
>>> print sum(l)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'Decimal' and 'float'
>>> print sum(l, Decimal(0))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'Decimal' and 'float'

the ternary operator is called 'conditional expression evaluation'
and is written
  a if condition else b

>>> l = [ 23, 123, 56 ]
>>> capped = [ 75 if v > 75 else v for v in l ]
>>> capped
[23, 75, 56]

use the enumerate function to supply sequence indices


>>> for i in xrange(501, 801, 100):
...   print i
... 
501
601
701
>>> for i in enumerate(xrange(501, 801, 100)):
...   print i
... 
(0, 501)
(1, 601)
(2, 701)

use itertools.izip to combine two sequences together one at a time
without buffering them all in memroy as zip does.

the for statement can take an else clause, which is executed at the end
of the for loop if it was not exited via break:

# ensure we found a blank line that signals a section  separator
for line in open("foo.txt"):
  stripped = line.strip()
  if not stripped:
    break
  # process line
else:
  raise RuntimeError("Missing section separator")

use raise by itself to re-raise an exception in a handler

assert(expr, msg)
can be used to make assertions in code

if __debug__:
  stmts

can be used as well.
When the optimize flag (-O) is passed to the interpreter, these statments are eliminated
from the byte code, minimizing the runtime effect.
The bottom line is that they support an assertion style of defensive programming.

any function that calls yield is a generator

The general form of try is:

try:
  f = open('foo.txt', 'r')
except IOError as e:
  print('Unable to open foo: %s\n' % e)
finally:
  f.close()


the finally clause is executed _before_ the exception, if any, is handled

def f():
  try:
    f = open('foo.txt', 'r')
  except IOError as e:
    print('Unable to open foo: %s\n' % e)
  else:
    data = f.read()
    print data
    f.close()

----------------
virtualenv installation on capella

first read the homebrew advice here:
https://github.com/mxcl/homebrew/wiki/Homebrew-and-Python

capella-> brew search pip
aespipe	    brew-pip	lesspipe    spiped	pipeviewer

If you meant `pip' precisely:

Install pip with easy_install:

    easy_install pip

capella-> sudo easy_install pip
capella-> sudo pip install virtualenvwrapper

Then add the bashrc glue:
      export WORKON_HOME=$HOME/.virtualenvs
      export PROJECT_HOME=/proj
      source /usr/local/bin/virtualenvwrapper.sh


----
python virtualenv for ffdev work on proteus:

first install python with brew
read homebrew advice Homebrew-and-Python above: {

     A "distutils.cfg" has been written to:
       /usr/local/Cellar/python/2.7.2/lib/python2.7/distutils
     specifing the install-scripts folder as:
       /usr/local/share/python

     If you install Python packages via "python setup.py install", easy_install, pip,
     any provided scripts will go into the install-scripts folder above, so you may
     want to add it to your PATH.

     Distribute has been installed, so easy_install is available.
     To update distribute itself outside of Homebrew:
         /usr/local/share/python/easy_install pip
         /usr/local/share/python/pip install --upgrade distribute
}

So that is what I did:
add /usr/local/share/python to $PATH
installed easy_install
upgraded distribute.

After this step I have:

sfo-mp8n0-> ls -l /usr/local/share/python/
total 32
-rwxr-xr-x  1 jmccarre  staff   349B May 25 01:28 easy_install*
-rwxr-xr-x  1 jmccarre  staff   357B May 25 01:28 easy_install-2.7*
-rwxr-xr-x  1 jmccarre  staff   301B May 25 01:28 pip*
-rwxr-xr-x  1 jmccarre  staff   309B May 25 01:28 pip-2.7*

----
Now I want to install virtualenvwrapper

http://www.doughellmann.com/projects/virtualenvwrapper/
says I have to install virtualenv separately.
So do that:

pip install virtualenv
  ...
    Installing virtualenv script to /usr/local/share/python

then back to v-e-wrapper

pip install virtualenvwrapper
