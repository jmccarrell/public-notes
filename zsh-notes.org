#+TITLE: Jeffs notes on zsh
#+STARTUP: showall

* Interesting snippets / idioms

use of ? expansion (which is the many expansions is this?) to produce newline separated path:

#+begin_src zsh
‚ùØ type path
path is an alias for echo -e ${PATH//:/\\n}

~
‚ùØ path
/Users/jeff/bin/MacOS
/Users/jeff/bin
/usr/local/bin
/usr/bin
/bin
/usr/sbin
/sbin
/opt/X11/bin
#+end_src

show read-only parameters

#+begin_src zsh
‚ùØ typeset -r
'!'=0
'#'=0
'$'=3588
'*'=(  )
-=059CDEJNQRTWXZghilms
'?'=0
@=(  )
ARGC=0
EPOCHREALTIME
EPOCHSECONDS
#+end_src

to see the attributes of a parameter, use +m

#+BEGIN_SRC ZSH
‚ùØ TYPESET +M PATH
ARRAY PATH
#+END_SRC

show all the params with a given attribute, like array, or associative array:

#+begin_src zsh
‚ùØ declare +m +a
*
@
ZSH_HIGHLIGHT_HIGHLIGHTERS
argv
cdpath
comppostfuncs
compprefuncs
dirstack
dis_patchars
dis_reswords
epochtime
fignore
fpath
  ...
#+end_src

#+begin_src zsh
‚ùØ declare +m +A
BG
FG
FX
ZSH_HIGHLIGHT_PATTERNS
ZSH_HIGHLIGHT_STYLES
aliases
builtins
commands
dis_aliases
dis_builtins
dis_functions
dis_functions_source
dis_galiases
dis_saliases
editor_info
functions
functions_source
galiases
history
#+end_src

show the attribute info of all params

#+begin_src zsh
‚ùØ declare +
integer 10 readonly !
integer 10 readonly #
integer 10 readonly $
array readonly *
readonly -
  ...
#+end_src

show parameters with the uniqueness attribute declared:

#+begin_src zsh
‚ùØ typeset -U +
_comp_assocs
cdpath
fpath
mailpath
path
prompt_themes
#+end_src

show the types of parameters matching a pattern:

#+begin_src zsh
‚ùØ declare +m "*path"
array cdpath
array fpath
array mailpath
array manpath
array module_path
array path
#+end_src

show all parameters and values matching a pattern:

#+begin_src zsh
‚ùØ declare -m "*path"
path=( /Users/jeff/bin/MacOS /Users/jeff/bin /usr/local/bin /usr/bin /bin /usr/sbin /sbin /opt/X11/bin )
module_path=( /usr/local/Cellar/zsh/5.4.2_1/lib )
mailpath=(  )
fpath=( /Users/jeff/.zprezto/modules/helper/functions /Users/jeff/.zprezto/modules/completion/external/src /Users/jeff/.zprezto/modules/osx/functions /Users/jeff/.zprezto/modules/git/functions /Users/jeff/.zprezto/modules/utility/functions /Users/jeff/.zprezto/modules/prompt/functions /usr/local/share/zsh/site-functions /usr/local/Cellar/zsh/5.4.2_1/share/zsh/functions )
cdpath=(  )
manpath=(  )
#+end_src

* zsh users guide notes / zsh dash info pages notes

prefer ~[[~ over ~[~ in all cases.
the zsh manual calls this a "compound command"
it is a ksh-era improvement over some of the issues with ~[~, ie

- string expansions need not be guarded for the empty string, ie

#+begin_src sh
[ "${var}X" == "somestringX" ]
#+end_src

is not needed.

** prefer ~print --~

recommended idiom: pass -- after every print so print will work even if the text begins with ~-~.
this saves grief when the printed text may look like an option to be parsed.
ie, prefer:

#+begin_src sh
print -- ${msg}
#+end_src

over

#+begin_src sh
print ${msg}
#+end_src

** SH_WORD_SPLIT

by default, zsh will not split the expansion of a multi word parameter on spaces as sh does
because it treats it as an array
but this shows that there are other places where expansion happens

to split an arg by spaces, use ~${=foo}~

#+begin_src sh :results output verbatim
zsh -s <<'eos'
function show_args() {
  echo num args: $#
  echo $@
}
foo=(every good boy does fine)
show_args $foo
show_args "$foo"
show_args ${foo[3]} $foo[5]
eos
#+end_src

#+RESULTS:
: num args: 5
: every good boy does fine
: num args: 1
: every good boy does fine
: num args: 2
: boy fine

** things to check out

zargs: a version of xargs that makes the find command redundant
zmv: a command for renaming files by means of shell patterns

** coprocesses

- [[https://www.zsh.org/mla/users/2011/msg00095.html][tutorial of sorts]]

** redirection

if the word behind a redirection symbol (eg ~<~) expands to multiple words, each of them is treated as a file and they are opened one by one to provide the input

#+begin_src sh :results output replace
zsh -s <<'eos'
echo every >! /tmp/one; echo good >! /tmp/two; files=(/tmp/{one,two}); cat -n <${files}; rm ${files};
eos
#+end_src

#+RESULTS:
:      1	every
:      2	good

the same effect can be had when multios are in effect without the use of an array:

#+begin_src sh :results output replace
zsh -s <<'eos'
setopt MULTIOS
echo every >! /tmp/one; echo good >! /tmp/two; cat -n < /tmp/one < /tmp/two; rm /tmp/{one,two};
eos
#+end_src

#+RESULTS:
:      1	every
:      2	good

*** here string

~<<< word~

#+BEGIN_QUOTE
Perform shell expansion on word and pass the result to standard input. This is known as a here-string.
Compare the use of word in here-documents above, where word does not undergo shell expansion
#+END_QUOTE

*** redirecting stdout and stderr

well, it would be nice to record the outputs here in org-mode, but the way org-mode executes the shell,
[[http://kitchingroup.cheme.cmu.edu/blog/2015/01/04/Redirecting-stderr-in-org-mode-shell-blocks/][it discards stderr]], apparently by design.

so these experiments are best done at the shell itself.

#+BEGIN_SRC sh :results output replace
zsh -s <<-'eos'
{
   print "stdout foo" >&1;
   print "stderr foo" >&2;
}
eos
#+END_SRC

gives

#+BEGIN_EXAMPLE
stderr foo
stdout foo
#+END_EXAMPLE

we can redirect these separately:

#+BEGIN_SRC sh
{ print "stderr foo" >&2; print "stdout foo" >&1; } > /dev/null;
#+END_SRC

#+BEGIN_EXAMPLE
stderr foo
#+END_EXAMPLE

#+BEGIN_SRC sh
{ print "stderr foo" >&2; print "stdout foo" >&1; } 2> /dev/null;
#+END_SRC

#+BEGIN_EXAMPLE
stdout foo
#+END_EXAMPLE

or both together:

#+BEGIN_SRC sh
{ print "stderr foo" >&2; print "stdout foo" >&1; } |& > /dev/null;
#+END_SRC

#+BEGIN_EXAMPLE
<empty; no output>
#+END_EXAMPLE

** arithmetic operations

zsh can natively show thousands, millions separators -- like my commify -- using an output base specifier. eg

#+BEGIN_SRC sh :results output replace
zsh <<-'eos'
print $(( [#_] 178316242 ))
eos
#+END_SRC

#+RESULTS:
: 178_316_242

this, of course, works with all of the bases (2 - 36) that zsh supports

#+BEGIN_SRC sh :results output replace
zsh <<-'eos'
setopt cbases
print $(( [#16_4] 65536 ** 2 ))
eos
#+END_SRC

#+RESULTS:
: 0x1_0000_0000

or with commas

#+BEGIN_SRC sh :results output replace
zsh <<-'eos'
print $(( [#_] 178316242 ))
eos
#+END_SRC

#+RESULTS:
: 178_316_242

> An arithmetic expression uses nearly the same syntax and associativity of expressions as in C.

in particular ~++~, ~--~ and all the bitwise operators are supported.
the ternary operator is supported, as well as the comma operator.

> the operators ~&&~, ~||~, ~&&=~ and ~||=~ are short circuiting, and only one of the two of the latter expressions in a ternary operator is evaluated.
** functions
to see the names of all declared functions: ~functions +~
to see names and function bodies: ~functions~
** string manipulation
*** reverse a string
#+BEGIN_SRC sh :results output
zsh <<-'eos'
#!/usr/bin/env zsh

function rev () {
    declare -a out
    while (( $# > 0 )); do
        # split $1 on character boundaries
        declare -a source=(${(ps..)1})
        shift
        declare -a result=()
        while (( $#source > 0 )); do
            result+=($source[-1])
            shift -p source
        done;
        # join the result array back down to a string
        out+=(${(j::)result})
    done
    print $out
    return 0
}

function show_rev() {
    print "$#:" $@
    print '>>' $(rev $@)
}
declare -a egbdf=(every good boy does fine)
show_rev $egbdf
show_rev "$egbdf"
declare -a racing_emoji=(racing_car_üèé racing_motorcycle_üèç horse_racing_üèá)
show_rev $racing_emoji
show_rev "$racing_emoji"
# the empty string
show_rev
eos
#+END_SRC

#+begin_example
5: every good boy does fine
>> yreve doog yob seod enif
1: every good boy does fine
>> enif seod yob doog yreve
3: racing_car_üèé racing_motorcycle_üèç horse_racing_üèá
>> üèé_rac_gnicar üèç_elcycrotom_gnicar üèá_gnicar_esroh
1: racing_car_üèé racing_motorcycle_üèç horse_racing_üèá
>> üèá_gnicar_esroh üèç_elcycrotom_gnicar üèé_rac_gnicar
0:
>>
#+end_example

* idiom to recursively list all files, including hidden files

> ( setopt globdots; print -l **/*(.) )
